#!/usr/bin/env python3### ---------------------------------------- ###def display_help():    """    This function displays a description of the script    """        help_text = """    This script processes a cross-sectional video of a D. melanogaster Malpighian    tubule and outputs the tubule, lumen, and cell width over time.    Parameters    ----------    --help : optional        Prints this help text and quits.    --sample_name : string, required        Name of sample, to be used as prefix for output files.    --movie : string path, required        Path to the movie to analuze.    --make_mask : optional        If used, this option will convert the movie to a mask.    --remove_background : optional        If used, this option will remove the background using a no-neighborg        algorithm prior to masking.    --scale : float, optional        Scale used to convert pixels measurements, expressed as unit/pixel.        Omit or set to 1 if unknown.    """    print(help_text)### ---------------------------------------- ###def parse_args():    """    This function parses command line arguments    """        print('Reading command line arguments')        print(f'args = {argv}')    # Sample name    sample_name = argv[argv.index('--sample_name') + 1]        # Path to movie (can be relative)    movie_path = argv[argv.index('--movie') + 1]        # Is the movie already masked?    if '--make_mask' in argv:                masking = True            else:                masking = False        # Remove background before masking?    if '--remove_background' in argv:                remove_background = True            else:                remove_background = False    if '--scale' in argv:        scale = float(argv[argv.index('--scale') + 1])    else:        scale = 1        return sample_name, movie_path, masking, remove_background, scale### ---------------------------------------- ###class malpighian_movie_processing:    """    Class for the processing of adult D. melanogaster malpighian tubules cross-    sectional, maximum-projection movies.    Parameters    ----------    movie_path : string        Path to movie to be analyzed.    masking : bool, optional        Set to true to mask the image, false if the image is already a mask.        Default = True    cleanup : bool, optional        Set to True if you want to remove the background using a no-neighborg        algorithm prior to masking.        Default = True    scale : float, optional        Scale used to convert pixels measurements, expressed as unit/pixel.        Default = 1    output_prefix : string, optional        Prefix to be used for output files.        Default = "data"    Attributes    ----------    movie : np.array        Movie stored as a numpy array.        Created on class init.    results : pd.DataFrame        Results of the movie analysis.        Created by process_movie function    Methods    -------    process_movie()        Processes the movie and creates a results table.    """    def __init__(self, movie_path, masking=True, cleanup=True, scale=1, output_prefix='data'):        # Set class vars        self.masking_toggle = masking        self.cleanup_toggle = cleanup        self.scale = scale        self.output_prefix = output_prefix        # Import movie        self.movie = self.image_importer(movie_path)    ### ------------------------------------ ###    ### PROCESSING                           ###    ### ------------------------------------ ###    def process_movie(self):        ### Preprocessing        # Masking movie, if required        if self.masking_toggle:                        # Removing background, if required            if self.cleanup_toggle:                                self.movie = self.clean_movie(self.movie, background_multiplier=0.5)                            # Save cleaned movie to file                self.save_tiff(self.movie, f'{self.output_prefix}_clean')                        # Thresholding            self.mask = self.mask_movie(self.movie)                        # Structure areas of the mask and remove lumen vescicles            self.mask = self.structure_mask(self.mask)                        # Save mask to file            self.save_tiff(self.mask, f'{self.output_prefix}_mask')        else:            self.mask = self.movie.copy()        ### Processing        # Init results header and list for storage        results_header = ['frame', 'tubule_mean_width', 'tubule_mean_width_std', 'lumen_mean_width', 'lumen_mean_width_std', 'cells_mean_width', 'cells_mean_width_std']        results = []        # Use lumen to define direction of tubule, then measure perpendicularly to it        for t,m in enumerate(self.mask):                        print(f'\rMeasuring frame {t + 1} / {self.mask.shape[0]}', end='')            m_measurements = [t] + self.measure_tubule(m)            results.append(m_measurements.copy())        self.results = pd.DataFrame(results, columns=results_header)        # Scale data        self.results.loc[:, [col for col in self.results.columns if col != 'frame']] *= scale        # Save to file        self.results.to_csv(f'{self.output_prefix}_measurements.tsv', sep='\t', index=False, header=True)        ### Plot results        self.plot_results(self.results, normalize=False, plot_name=f'{self.output_prefix}_measurements_raw.png')        self.plot_results(self.results, normalize=True, plot_name=f'{self.output_prefix}_measurements_normalized.png')    ### ------------------------------------ ###    @staticmethod    def clean_movie(mov, background_multiplier=0.5):                # Using no-neighbour deblurring (i.e. simulating background by blurring image using different sigmas) to find foreground        print("Running no-neighbour deblurring")                # Smoothening the image using a mean filter        clean_mov = correlate(mov, np.ones((1, 3, 3)) / 9, mode="same")                # To make the calculation faster, mov is downscaled to find background        clean_mov = np.array([np.array(img.fromarray(t).resize((int(t.shape[1] / 4), int(t.shape[0] / 4)))) for t in mov])                # Simulating background        background = np.zeros(clean_mov.shape)                for sigma in [5, 10, 20]:                        background = np.max((background, gaussian(clean_mov, (0, sigma, sigma), mode="reflect")), 0)                clean_mov = (clean_mov - background * background_multiplier) # Adjusting background intensity        # Reshaping to 8bit        clean_mov = (clean_mov * 255 / np.max(clean_mov)).astype('int16')                # Restore original size        clean_mov = np.array([np.array(img.fromarray(m).resize((mov.shape[2], mov.shape[1]))) for m in clean_mov])                clean_mov[clean_mov < 0] = 0        return clean_mov    ### ------------------------------------ ###    @staticmethod    def mask_movie(mov):                masks = []                for t,m in enumerate(mov):                        best_thr, lumen_area = 0, 0                        for thr in np.sort(np.unique(m)):                                # Threshold image                mask = (m <= thr)                                # Find blank objects (i.e. empty imaging area and tubule lumen)                labels, labels_num = label(mask, np.ones((3, 3)))                labels_areas = [(lb, (labels == lb + 1).sum()) for lb in range(labels_num)]                labels_areas.sort(key=lambda x: x[1], reverse=True)                                # Skip if less than 3 objects or if third is smaller than a 10th of the first two                if labels_num < 3:                                        continue                                if labels_areas[2][1] < 0.05 * labels_areas[1][1]:                                        continue                                if labels_areas[2][1] >= lumen_area:                                        best_thr, lumen_area = thr, labels_areas[2][1]                                else:                                        masks.append(m <= best_thr)                                        print(f'\rMasked {t + 1} / {mov.shape[0]} frames', end='')                                        break                        masks = np.array(masks)                return masks    ### ------------------------------------ ###    @staticmethod    def structure_mask(mov):                # Set background areas outside tubule as 1 and 2, and lumen area as 3                cleaned_mov = []        for m in mov:                        # Find blank objects (i.e. empty imaging area and tubule lumen)            labels, labels_num = label(m, np.ones((3, 3)))            labels_areas = [(lb, (labels == lb + 1).sum()) for lb in range(labels_num)]            labels_areas.sort(key=lambda x: x[1], reverse=True)            labels_of_interest = [l[0] + 1 for l in labels_areas[:3]]                        # Define lumen as the label with centroid between the centroids of the two background areas            centroids = [np.median(np.array(np.where(labels == lb)), axis=1) for lb in labels_of_interest]            ab_distance = np.power(np.sum(np.power(centroids[0] - centroids[1], 2)), 0.5)            ac_distance = np.power(np.sum(np.power(centroids[0] - centroids[2], 2)), 0.5)            bc_distance = np.power(np.sum(np.power(centroids[1] - centroids[2], 2)), 0.5)                        if ab_distance > ac_distance and ab_distance > bc_distance:                                bg1_label, bg2_label, lumen_label = labels_of_interest[0], labels_of_interest[1], labels_of_interest[2]                        elif ac_distance > ab_distance and ac_distance > bc_distance:                                bg1_label, bg2_label, lumen_label = labels_of_interest[0], labels_of_interest[2], labels_of_interest[1]                        elif bc_distance > ab_distance and bc_distance > ac_distance:                                bg1_label, bg2_label, lumen_label = labels_of_interest[1], labels_of_interest[2], labels_of_interest[0]                        else:                                pass # Never going to happen                        # Expansion and erosion to close holes and fill small ones            radius = (10, 10)            lumen_mask = minfil(maxfil(labels == lumen_label, radius), radius)                        # Filling holes            lumen_mask = fill(lumen_mask)                        # Update masked frame            new_mask = np.zeros(m.shape)            new_mask[labels == bg1_label] = 1            new_mask[labels == bg2_label] = 2            new_mask[lumen_mask] = 3                        cleaned_mov.append(new_mask)                cleaned_mov = np.array(cleaned_mov)        return cleaned_mov    ### ------------------------------------ ###    ### IMAGE IMPORT/EXPORT                  ###    ### ------------------------------------ ###    @staticmethod    def image_importer(path, max_frames=10000):                print(f'Importing image {path}')                raw = img.open(path)                movie_arr = []                for r in range(0, max_frames):                        try:                                raw.seek(r)                movie_arr.append(np.array(raw))                        except:                                break        movie_arr = np.array(movie_arr, dtype='int16') # int8 was giving problems, i.e. bright pixels, close to 256, were converted to 0                raw.close()                print("Image has been successfully imported")                return movie_arr    ### ------------------------------------ ###    @staticmethod    def save_tiff(img_arr, output_prefix='pic'):                # Exporting mask as multipage tiff in zipped archive        buffer = BytesIO()                img_arr = [img.fromarray(ia) for ia in img_arr]        img_arr[0].save(buffer, "TIFF", save_all=True, append_images=img_arr[1:])                zf = ZipFile(f'{output_prefix}.zip', mode="w", compression=ZIP_DEFLATED)        zf.writestr(f'{output_prefix}.tif', buffer.getvalue())        zf.close()    ### ------------------------------------ ###    ### TUBLE ANALYSIS                       ###    ### ------------------------------------ ###    def measure_tubule(self, m):                # Init lists for tubule, lumen, and cell thickness        tubule_measurements, lumen_measurements, cells_measurements = [], [], []                # Labels used in structure_mask function        bg1_label, bg2_label, lumen_label = 1, 2, 3                # Cluster points and find centroids that better define the direction of the tubule        lumen_spine = self.find_centroids(m, lumen_label)                # Every N points, make a perpendicular projection and calculate lumen and tubule width, as well as cell thickness        n_measurements = 100        n_points = round(len(lumen_spine) / n_measurements)        for i in range(0, len(lumen_spine), n_points):                        ls1, ls2 = lumen_spine[i], lumen_spine[min(len(lumen_spine) - 1, i + n_points)]            midpoint = lumen_spine[min(len(lumen_spine) - 1, i + int(n_points / 2))]                        # Find gradient and intercept of perpendicular line to lumen_spine at ls1            if ls1[0] != ls2[0] and ls1[1] != ls2[1]:                                gradient = - (ls2[1] - ls1[1]) / (ls2[0] - ls1[0])                        elif ls1[0] == ls2[0] and ls1[1] != ls2[1]:                                gradient = 0                            elif ls1[0] != ls2[0] and ls1[1] == ls2[1]:                                gradient = 1e9                            else:                                continue                        intercept = midpoint[1] - gradient * midpoint[0]                        # Create perpendicular line            perpendicular = np.array([[x, round(x * gradient + intercept)] for x in range(m.shape[0])])            perpendicular = perpendicular[(perpendicular[:,1] >= 0) & (perpendicular[:,1] < m.shape[1]),]                        # Extract mask profile            profile = m[perpendicular[:, 0], perpendicular[:, 1]].copy()                        # Extract tubule and lumen width, and cells size            bg1_coords = np.where(profile == bg1_label)[0]            bg2_coords = np.where(profile == bg2_label)[0]            lumen_coords = np.where(profile == lumen_label)[0]                        try:                                tubule_width = bg2_coords.min() - bg1_coords.max() if bg1_coords.min() < bg2_coords.min() else bg1_coords.min() - bg2_coords.max()                lumen_width = lumen_coords.max() - lumen_coords.min()                cells_width = (tubule_width - lumen_width) / 2 # N.B. Divided by two since there's cells on both sides                        except:                                continue            tubule_measurements.append(tubule_width)            lumen_measurements.append(lumen_width)            cells_measurements.append(cells_width)                tubule_mean_width, tubule_mean_width_std = np.mean(tubule_measurements), np.std(tubule_measurements)        lumen_mean_width, lumen_mean_width_std = np.mean(lumen_measurements), np.std(lumen_measurements)        cells_mean_width, cells_mean_width_std = np.mean(cells_measurements), np.std(cells_measurements)        return [tubule_mean_width, tubule_mean_width_std, lumen_mean_width, lumen_mean_width_std, cells_mean_width, cells_mean_width_std]    ### ------------------------------------ ###    def find_centroids(self, labeled_space, label_of_interest):                """        Finding centroids that best describe the profile of the object once        connected.        Algorithm works by first clustering points using k-means, then finding        the centroid of each cluster, connecting them and computing the average        distance of these points from the closest non-object point.        The best solution is the one where the centroids and the points        connecting them are more in the center of the object, i.e. the average        distance to the closest non-object point is maximized.        """                # EDT tranformation        edt_transform = distance_transform_edt((labeled_space == label_of_interest), return_distances=True)                # Find points that belong to the label_of_interest        coords = np.array(np.where(labeled_space == label_of_interest)).T                best_mean_distance_from_edges = 0        for n_centroids in [5, 10, 15, 20]:                    # KMeans clustering of the coordinates            xmin, ymin = coords.min(axis=0)            xmax, ymax = coords.max(axis=0)            init_centroids = np.array([np.linspace(xmin, xmax, n_centroids, endpoint=True),                                       np.linspace(ymin, ymax, n_centroids, endpoint=True)]).T            kmeans = KMeans(n_clusters=n_centroids, init=init_centroids, n_init=1)            coords_clustering = kmeans.fit_predict(coords)                        # Finding centroids as the median of each cluster            centroids = np.array([np.median(coords[coords_clustering == cl], axis=0) for cl in range(n_centroids)])                        # Check that centroids belong to the coords space            centroids_check = (sum([labeled_space[int(c[0]), int(c[1])] == label_of_interest for c in centroids]) == n_centroids)                        if not centroids_check:                                continue                        # Sort centroids and order them starting from the furthest one from the center, then calculate angles changes            centroids = centroids.tolist()            centroids.sort(key=lambda c: ((c[0] - labeled_space.shape[1])**2 + (c[1] - labeled_space.shape[0])**2)**0.5, reverse=True)            starting_centroid = centroids[0]                        sorted_centroids = [starting_centroid]            while len(sorted_centroids) < len(centroids):                                cnt = sorted_centroids[-1]                                    centroids.sort(key=lambda c: ((c[0] - cnt[0])**2 + (c[1] - cnt[1])**2)**0.5, reverse=False)                                i = 1                next_centroid = centroids[i]                while next_centroid in sorted_centroids:                                        i += 1                    next_centroid = centroids[i]                                sorted_centroids.append(next_centroid)                            sorted_centroids = np.array(sorted_centroids)                                object_spine = np.concatenate([sorted_centroids[:1]] +                                          [self.get_points_in_between(start, stop)[1:] for start, stop in zip(sorted_centroids, sorted_centroids[1:])])                        # Diagnostic plot            #plt.imshow(labeled_space == label_of_interest)            #plt.plot(sorted_centroids[:, 1], sorted_centroids[:, 0], 'go', markersize=5)            #plt.plot(object_spine[:, 1], object_spine[:, 0], 'r', linewidth=1)                        mean_distance_from_edges = sum([edt_transform[int(os[0]), int(os[1])] for os in object_spine]) / len(object_spine)                        if best_mean_distance_from_edges < mean_distance_from_edges:                                best_mean_distance_from_edges = mean_distance_from_edges                #best_n = n_centroids                best_spine = object_spine.copy()                # Diagnostic        #print(best_n)                return best_spine    ### ------------------------------------ ###    @staticmethod    def get_points_in_between(start, stop):                distance = round(((stop[0] - start[0])**2 + (stop[1] - start[1])**2)**0.5)        x_shift, y_shift = stop - start                points = []                for d in range(distance):                        new_point = [start[0] + round(d * x_shift / distance), start[1] + round(d * y_shift / distance)]            points.append(new_point)                if list(stop) not in points:                        points.append(stop)                points = np.array(points)                return points    ### ------------------------------------ ###    ### PLOTTING                             ###    ### ------------------------------------ ###    @staticmethod    def plot_results(res, normalize=False, plot_name='measurements.png'):                fig, axes = plt.subplots(3, 1, sharex=True, sharey=True)        fig.set_figwidth(15)        fig.set_figheight(9)        for ax,var,color in zip(axes.reshape(-1), ['tubule', 'lumen', 'cells'], ['red', 'blue', 'green']):                        x = res.frame.values.copy()            top = res.loc[:, f'{var}_mean_width'].values.copy() + res.loc[:, f'{var}_mean_width_std'].values.copy()            middle = res.loc[:, f'{var}_mean_width'].values.copy()            bottom = res.loc[:, f'{var}_mean_width'].values.copy() - res.loc[:, f'{var}_mean_width_std'].values.copy()                        if normalize:                                norm_factor = top.max()                top = top / norm_factor                middle = middle / norm_factor                bottom = bottom / norm_factor                            ax.title.set_text(var)            ax.plot(x,                    middle,                    c=color,                    ls='-',                    lw=3)            ax.plot(x,                    top,                    c=color,                    ls='--',                    lw=1)                        ax.plot(x,                    bottom,                    c=color,                    ls='--',                    lw=1)                        ax.fill_between(x,                            bottom,                            top,                            color=color,                            alpha=0.25)                        if var == 'lumen':                                ax.set_ylabel('Width (px)')        plt.xlabel('Time (frames)')        plt.tight_layout()        plt.savefig(plot_name, dpi=300)        plt.close()### ------------------MAIN------------------ ###try:        import numpy as np    import pandas as pd        from io import BytesIO    from matplotlib import pyplot as plt    from PIL import Image as img    from scipy.ndimage import binary_fill_holes as fill    from scipy.ndimage import gaussian_filter as gaussian    from scipy.ndimage import distance_transform_edt    from scipy.ndimage import label    from scipy.ndimage import minimum_filter as minfil    from scipy.ndimage import maximum_filter as maxfil    from scipy.signal import correlate #Easier math than convolution    from sklearn.cluster import KMeans    from sys import argv    from zipfile import ZipFile    from zipfile import ZIP_DEFLATED    except:        print("One or more dependencies are not installed.\nAlso, make sure your terminal has been activated.")    exit()### Read CLIif '--help' in argv or '-h' in argv:        display_help()    quit()else:        sample_name, movie_path, masking, remove_background, scale = parse_args()### Processing# Init classanalysis = malpighian_movie_processing(movie_path, masking, remove_background, scale, sample_name)# Process movieanalysis.process_movie()